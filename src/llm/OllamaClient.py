from typing import Dict, Optional, List, Any
import json
import os
from datetime import datetime
import requests
import re
from termcolor import colored
from console_manager import console


class OllamaClient:
    """Class to handle Ollama API calls."""
    def __init__(self, model: str = "llama3.2:latest", base_url: str = "http://localhost:11434", keep_alive: str = "5m", verbose: bool = True):
        self.model = model
        self.base_url = base_url.rstrip('/')
        self._initialized = False
        self.verbose = verbose
        self.keep_alive = keep_alive
        
    def is_initialized(self) -> bool:
        return self._initialized
    
    def initialize(self, options: Dict[str, Any]):
        if not self._is_model_available():
            console.process(f"Model {self.model} not found. Starting download...")
            self._download_model()

        self._initialized = True

    def save_conversation(self, messages: List[Dict], filename: Optional[str] = None):
        """Save the conversation to a JSON file.
        
        Args:
            messages (list): List of message dictionaries
            filename (str, optional): The filename to save to
        """
        if not filename:
            filename = datetime.now().strftime("%Y-%m-%d_%H-%M-%S") + "_conversation.json"
        with open(filename, 'w') as f:
            json.dump(messages, f, indent=4)

    def stream_completion(self, messages, model, **kwargs):
        """
        Stream text completions from the Ollama API.

        Args:
            messages (list): List of messages used as context or prompt.
            model (str): Model identifier for text generation.
            **kwargs: Additional keyword arguments for the API request.

        Yields:
            str: Text generated by the Ollama API in response to the messages.
        """
        url = f"{self.base_url}/api/chat"
        data = {
            "model": model,
            "messages": messages,
            "stream": True,
            "keep_alive": self.__fix_keep_alive(self.keep_alive),
            **kwargs
        }
        json_data = json.dumps(data)
        # headers = {'Authorization': f'Bearer {self.api_key}'} if self.api_key else {}
        try:
            with requests.post(url, data=json_data, stream=True) as response:
                if response.status_code == 200:
                    for chunk in response.iter_content(chunk_size=None):
                        if chunk:
                            # Parse the JSON response and extract the content
                            response_data = json.loads(chunk)
                            yield response_data['message']['content']
                else:
                    if self.verbose:
                        print(f"Request failed with status code {response.status_code}")
                    raise RuntimeError(f"Request failed with status code {response.status_code}")
        except Exception as e:
            if self.verbose:
                import traceback
                traceback.print_exc()
            else:
                print(f"An error occurred streaming completion from Ollama API: {e}")
            raise RuntimeError(f"An error occurred streaming completion from Ollama API: {e}")
        
    def __fix_keep_alive(self, keep_alive):
        """ Attempts to fix the keep_alive value if it is not a valid string. Returns -1 as a fallback. """
        try:
            return int(keep_alive)
        except ValueError:
            pattern = r"^-?\d+[smh]$"
            if re.match(pattern, keep_alive) is not None:
                return keep_alive
            print(f"Invalid OLLAMA_KEEP_ALIVE value: {keep_alive}. Must be a number followed by s, m, or h.")
            return -1


    def cleanup(self):
        self.model = None
        self._initialized = False

    def _is_model_available(self) -> bool:
        """Check if the specified model is available locally."""
        try:
            url = f"{self.base_url}/api/tags"
            response = requests.get(url)
            if response.status_code == 200:
                models = response.json().get('models', [])
                return any(model['name'] == self.model for model in models)
            return False
        except Exception as e:
            console.error(f"Error checking model availability: {e}")
            return False

    def _download_model(self) -> bool:
        """Download the specified model."""
        try:
            url = f"{self.base_url}/api/pull"
            data = {"name": self.model}
            
            def format_size(bytes: int) -> str:
                """Convert bytes to human readable format."""
                for unit in ['B', 'KB', 'MB', 'GB']:
                    if bytes < 1024:
                        return f"{bytes:.2f} {unit}"
                    bytes /= 1024
                return f"{bytes:.2f} TB"
            
            with console.create_progress_bar(f"Downloading {self.model}") as progress:
                task = progress.add_task("Pulling manifest...", total=100)
                
                response = requests.post(url, json=data, stream=True)
                if response.status_code == 200:
                    for line in response.iter_lines():
                        if line:
                            status = json.loads(line)
                            if 'status' in status:
                                if status['status'] == 'pulling manifest':
                                    progress.update(task, description="Pulling manifest...")
                                elif 'total' in status and 'completed' in status:
                                    # Calculate percentage for progress bar
                                    percentage = (status['completed'] / status['total']) * 100
                                    downloaded = format_size(status['completed'])
                                    total_size = format_size(status['total'])
                                    progress.update(task, 
                                                 description=f"Downloading: {self.model} ({downloaded}/{total_size})", 
                                                 completed=percentage)
                                elif status['status'] == 'verifying sha256 digest':
                                    progress.update(task, description="Verifying sha256 digest...", completed=95)
                                elif status['status'] == 'writing manifest':
                                    progress.update(task, description="Writing manifest...", completed=98)
                                elif status['status'] == 'removing any unused layers':
                                    progress.update(task, description="Cleaning up...", completed=99)
                                elif status['status'] == 'success':
                                    progress.update(task, description="Complete!", completed=100)
                    
                    console.success(f"Model {self.model} downloaded successfully!")
                    return True
                else:
                    console.error(f"Failed to download model: Status code {response.status_code}")
                    return False
        except Exception as e:
            console.error(f"Error downloading model: {str(e)}")
            return False