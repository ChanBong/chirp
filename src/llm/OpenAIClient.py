from typing import Dict, Optional, Any
import os
import openai
from dotenv import load_dotenv
from console_manager import console

class OpenAIClient:
    """Class to handle OpenAI API calls."""
    def __init__(self, model: str = "gpt-4o", api_key: Optional[str] = None, verbose: bool = True):
        load_dotenv()
        self.model = model
        self._initialized = False
        self.verbose = verbose
        self.api_key = api_key or os.getenv('OPENAI_API_KEY')
        if not self.api_key:
            raise ValueError("API key must be provided either as an argument or through the environment variable 'OPENAI_API_KEY'.")
        
        openai.api_key = self.api_key
        self.client = openai.Client()

    def is_initialized(self) -> bool:
        return self._initialized
    
    def initialize(self, options: Dict[str, Any]):
        self._initialized = True

    def stream_completion(self, messages, model, **kwargs):
        """Get completion from OpenAI API.

        Args:
            messages (list): List of messages.
            model (str): Model for completion.
            **kwargs: Additional keyword arguments.

        Yields:
            str: Text generated by the OpenAI API.
        """
        try:
            # Process messages to handle multimodal content
            processed_messages = []
            for message in messages:
                content = []
                
                # Handle text content
                if isinstance(message.get('content'), str):
                    content.append({"type": "text", "text": message['content']})
                elif isinstance(message.get('content'), list):
                    for item in message['content']:
                        if item.get('type') == 'image':
                            content.append({
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:{item['source']['media_type']};base64,{item['source']['data']}"
                                }
                            })
                        else:
                            content.append(item)
                
                processed_messages.append({
                    "role": message['role'],
                    "content": content if content else message.get('content')
                })

            stream = self.client.chat.completions.create(
                model=model,
                messages=processed_messages,
                stream=True,
                **kwargs
            )
            for chunk in stream:
                content = chunk.choices[0].delta.content
                if content is not None:
                    yield content
        except Exception as e:
            if self.verbose:
                import traceback
                traceback.print_exc()
            else:
                print(f"An error occurred streaming completion from OpenAI: {e}")
            raise RuntimeError(f"An error occurred streaming completion from OpenAI: {e}")


    def cleanup(self):
        self.model = None
        self._initialized = False

    def generate_response(self, messages):
        try:
            console.process("Generating response from OpenAI...")
            # ... existing code ...
            console.success("Response generated successfully")
            return response
        except Exception as e:
            console.error(f"Error generating response: {str(e)}")
            raise
